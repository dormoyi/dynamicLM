---
title: "Landmark supermodel"
output: 
 html_document:
  toc: true
  toc_depth: 3  				# upto three depths of headings (specified by #, ## and ###)
  number_sections: true 	# if you want number sections at each table header
---

# Required packages
```{r, message=F, warning=F}
#install dplyr
# install.packages("dplyr")
library(tictoc) # to time code, can ignore
library(dplyr)
# install_github("thehanlab/dynamicLM", 
#                ref = "extension/summary-metric", 
#                force = TRUE)

# library(dynamicLM)

library(devtools)
load_all()
# install_github("dormoyi/dynamicLM", ref = "main")

# library(dynamicLM)

```




# Load dataset  
Please ensure that the long-form dataset does not have any 'factor' variable. (Change it to dummy, or recode it as 0/1.)

```{r, warning = FALSE} 



df <- read.csv("C:\\Users\\idormoy\\Documents\\counterfactual_lung_cancer_surveillance\\penLM\\data\\pen_lm_input.csv")


df$time_index <- round(df$time_index/365.25,1)
df$time_to_event <- round(df$time_to_event/365.25,1)

# Only have unique id, time_index
df <- df[!duplicated(df[, c("MRN_FULL", "time_index")]), ]

head(df)
```

```{r}
par(mfrow=c(1,2))
hist(df$time_index)
hist(df$time_to_event)
````


# dynamicLM data transformation 
## Basic setting


Notes:

1. Changes lms to be 4->10 by 1 as most of the patient entries and events are in this range.
2. The many NAs come from patients who do not have a "baseline" entry, so, when you "get" their data at e.g., landmark 4, there is not information to retrieve. Either: 
  a. impute a baseline entry for each patient
  b. fit the model with only the complete entries (current solution)
  c. choose a subset of patients with entries at or after some point (e.g., 5) and develop the model with this patient group.

```{r}
# Pick landmarks and window on the above
w <- 1 # Predict the 5-year outcome
lms <- seq(5, 10, by = 1) # Risk assessment time points 

# Specify outcome and exposure types
outcome <- list(time = "time_to_event", status = "EventMortality")
varying = c("Xray_count", "priorCT_3mon", "priorCT_6mon", "provider_onc",
            "provider_med", "Surveillance", "FollowUp", "Symptom", "Nodule",
            "Metastasis", "Recurrence", "Stable", "Effusion", "SystemicTreat",
            "DefinitiveTreat", "LC_Treat_Drug")
fixed <- c("age.ix", "SexVar", 
           grep('StageVar*', names(df), value = TRUE),
           grep('HistVar*', names(df), value = TRUE), 
           grep('RaceVar*', names(df), value = TRUE),
           grep('icd10_loc*', names(df), value = TRUE))
# fixed <- setdiff(fixed, c("StageVar_Unknown", "HistVar_Squamous.cell",
#                           "RaceVar_White", "icd10_loc_upper.lobe")) 
#           # need to drop one of each category to avoid collinearity
covs <- c(varying, fixed)

# Train/test
set.seed(40)
train_id <- sample(unique(df$MRN_FULL), length(unique(df$MRN_FULL)) * 0.7)
test_id <- unique(df$MRN_FULL)[!unique(df$MRN_FULL) %in% train_id]

print(paste("Number of patients in training set:", length(train_id)))
print(paste("Number of patients in test set:", length(test_id)))

# import stack_data.R

# Data transformation
lmdata <- stack_data(data = df[df$MRN_FULL %in% train_id, ], 
                     outcome = outcome, lms = lms, w = w, 
                     covs = list(fixed = fixed, varying = varying), fixed,
                     format = "long", id = "MRN_FULL", rtime = "time_index")
lmdata_test <- stack_data(data = df[!df$MRN_FULL %in% test_id, ], 
                     outcome = outcome, lms = lms, w = w, 
                     covs = list(fixed = fixed, varying = varying), fixed,
                     format = "long", id = "MRN_FULL", rtime = "time_index")



dat.lm <- lmdata$data
dat.lm <- dat.lm[order(dat.lm$MRN_FULL, dat.lm$LM),]



# get number of lines with at least one NA
sum(complete.cases(dat.lm) == FALSE) # 0
# get total number of lines
nrow(dat.lm) 
nrow(lmdata$data) # 1164? TODO check this
```

```{r}
head(lmdata$data)

# sort by MRN_FULL, LM
lmdata$data <- lmdata$data[order(lmdata$data$MRN_FULL, lmdata$data$LM), ]

# show histogram with occurrences of time_to_ct in lmdata$data
hist(lmdata$data$time_to_ct, breaks = 100)

# what percentage of the time_to_ct are between -3 and 3?
sum(lmdata$data$time_to_ct >= -3 & lmdata$data$time_to_ct <= 3) / nrow(lmdata$data) # 0.99

# what percentage of the time_to_ct are between -0.5 and 0.5?
sum(lmdata$data$time_to_ct >= -0.5 & lmdata$data$time_to_ct <= 0.5) / nrow(lmdata$data) # 0.75

# save histogram as png
# png("C:\\Users\\idormoy\\Documents\\counterfactual_lung_cancer_surveillance\\penLM\\data\\time_to_ct_hist.png")

```

## Automatic generation of time*interaction terms to test time-dependent effects 
```{r}
# Add interaction terms to evaluate time-dependent effect of included covariates 
# linear interaction term = var * LM (denoted as _1), 
# quadratic interaction term = var * LM^2 (denoted as _2)


lmdata <- add_interactions(lmdata = lmdata, lm_covs = covs,
                           func_covars = c("linear", "quadratic"), 
                           func_lms = c("linear", "quadratic"))
lmdata_test <- add_interactions(lmdata = lmdata_test, lm_covs = covs,
                           func_covars = c("linear", "quadratic"), 
                           func_lms = c("linear", "quadratic"))


# save lmdata$data as csv
write.csv(lmdata$data[order(lmdata$data$MRN_FULL, lmdata$data$LM),], "C:\\Users\\idormoy\\Documents\\dynamicLM\\input_before_penLM.csv", row.names = FALSE)

# colnames(lmdata$data)
```


# Landmark cause-specific Cox model fitting 

```{r, warning = F}
#####################
# 1. Full cox model #
# Note: full.cox does not converge
#####################

# formula <- paste("Surv(LM, time_to_event, EventMortality) ~", 
#                  paste0(lmdata$all_covs, collapse = " + "), 
#                  "+ cluster(MRN_FULL)")
# full.cox <- dynamic_lm(lmdata = lmdata, formula = as.formula(formula), 
#                          type = "coxph", 
#                          x = TRUE)
# print(full.cox)

####################
# 2. Partial model #
# Here is a partial model (some covariates) so you can see how an unpenalized model is fit


# install.packages("survival")
library("survival")

####################

formula <- "Surv(LM, time_to_event, EventMortality) ~ 
              SexVar + SexVar_1 + 
              DefinitiveTreat + DefinitiveTreat_1 + 
              Nodule + Nodule_1 +
              LM_1 + cluster(MRN_FULL)"
example.cox <- dynamic_lm(lmdata = lmdata, formula = as.formula(formula),
                         type = "coxph",
                         x = TRUE)
# print(example.cox)

######################
# 3. Penalized model #
# L2 norm, lambda chosen automatically with cross-validation
# Slower code, approx 2 min to run
######################

lmdata_complete <- lmdata
lmdata_complete$data <- lmdata$data[complete.cases(lmdata$data), ]



# cross validation
# this model stores the full set of lambdas, etc
tic("Cross validation")
cv.cox <- cv.pen_lm(lmdata_complete) 
toc()
```

```{r}



# pick the best lambda and fit one model we can use
# "lambda.min", "lambda.1se" or a numeric value
pen.cox <- dynamic_lm(cv.cox, lambda = "lambda.min") 
#print(pen.cox)
```

## Model visualisation... (optional)

```{r, fig.height=2, fig.width=6}



# install.packages("msm")
library(msm)

par(mfrow=c(1,3))

# plot the dynamic hazard ratio of a normal cox model
plot(example.cox)
# plot(example.cox, xlim=c(0, 10), ylim=c(0, 10), xlab="X-axis label", ylab="Y-axis label")
```

```{r}
# print/plot cross validated lambda values
# print(cv.cox)
plot(cv.cox)
```


```{r, fig.height=6, fig.width=8}
# plot penalized model coefficients
par(mar=c(5,13,4,1)+0.3, mfrow=c(1,1))
plot(pen.cox)
```

# Model evaluation 
## Predicted risk 
```{r}
# since the first event is at time 5, we need the window to be at least 1 when predicting from landmark 4
# can alternatively consider the following: only start making predictions from time 5 (so we can consider smaller windows)

# Some comments
# * a window of 0 does not work but a small one (e.g., 0.1) does
# * however, when it is small then it does not stratify well...
# * you can play with this w and see how the calibration plots change



lmdata_test1 <- lmdata_test
lmdata_test1$data <- lmdata_test$data[lmdata_test$data$LM >= 5 & 
                                        complete.cases(lmdata_test$data), ]

# preds_cox <- predict(example.cox, w = 1, newdata = lmdata_test1) # check later how to do the cox prediciton
preds_cox <- predict(pen.cox, w = 1, newdata = lmdata_test1) # ? or pred pen?
```

```{r}
# If you want to have a df with preds combined with id info
combined.preds <- preds_cox$data[, c("MRN_FULL", "time_to_event", "EventMortality")]
combined.preds$cox_risk <- preds_cox$preds$risk
combined.preds$pen_risk <- preds_pen$preds$risk
head(combined.preds)

# number of lines in combined.preds
nrow(combined.preds) # 987
nrow(lmdata_test1$data) # 987
```

```{r}
# unique(combined.preds$MRN_FULL)

# # get c-index with time_to_event and pen_risk
# cindex <- cindex(combined.preds$time_to_event, combined.preds$pen_risk)

# help(cindex)


# A1  <- pec::cindex(list("Cox X1"=cox1),
# 		  formula=Surv(time,status)~X1+X2,
# 		  data=dat,
# 		  eval.times=10)

# usage example


#### RATHER EXPORT THE RESULTS TO PYTHON SO WE CAN USE THE SAME C-INDEX FUNCION
# model pred, label whether event occurs, time to event

# create a df with MRN_FULL, pen_risk, EventMortality, time_to_event
# export to python
# calculate c-index in python
pen_risk <- combined.preds$pen_risk
EventMortality <- combined.preds$EventMortality
time_to_event <- combined.preds$time_to_event
MRN_FULL <- combined.preds$MRN_FULL
df <- data.frame(MRN_FULL, pen_risk, EventMortality, time_to_event)

# sort df by MRN_FULL, time_to_event
df <- df[order(df$MRN_FULL, df$time_to_event), ]
# print(df)

# print columns of combined.preds
colnames(combined.preds)

# write.csv(df, "C:\\Users\\idormoy\\Documents\\counterfactual_lung_cancer_surveillance\\penLM\\data\\pen_lm_output.csv", row.names = FALSE)


```


## Apparent validation
### Calibration
```{r, fig.height=7, fig.width=9}



# install.packages("pec")
library(pec)



par(mfrow = c(2, 3))



cal <- calplot(list("Penalized model" = preds_pen, "Simple model" = preds_cox),
               # times = c(5,6,7,8),
               # xlim = c(0.3, 1), ylim = c(0.3, 1),
               method = "quantile", q = 10) # deciles
```

```{r}
preds_cox
```

### Discrimination & Predictive accuracy 
```{r, fig.height=5, fig.width=9}



performance <- score(list("Penalized model" = preds_pen, "Simple model" = preds_cox))

par(mfrow=c(1,2))
plot(performance, se = FALSE) # hide error bars
```
